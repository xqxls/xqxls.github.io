### 1.说下你对HashMap的了解？

1. **数据结构**：HashMap基于哈希表实现。它使用哈希函数将键映射到数组索引，并将值存储在相应的索引位置上。这使得通过键快速查找值成为可能。
2. **键唯一性**：HashMap的键是唯一的，不能重复。如果尝试使用相同的键插入多个值，后续的值将会覆盖先前的值。
3. **Null键与Null值**：HashMap允许一个键为null，同时也允许多个值为null。这意味着你可以使用null键来映射一个值，或者将一个键对应的值设置为null来删除该键。
4. **时间复杂度**：在理想情况下（没有哈希冲突），HashMap的插入、查找和删除操作都具有O(1)的时间复杂度。但是，由于哈希冲突的可能性，时间复杂度可能会退化到O(n)，其中n是哈希表的大小。
5. **遍历**：遍历HashMap时，由于没有固定的顺序，无法保证元素的顺序。如果需要按照特定顺序遍历，可以使用其他实现如LinkedHashMap。
6. **容量和负载因子**：HashMap有一个初始容量，并且随着元素的添加和删除，其容量会自动调整。负载因子用于控制容量调整的阈值。当HashMap中的元素数量达到容量与负载因子的乘积时，会触发扩容操作，以保持哈希表的效率。
7. **线程不安全**：HashMap是非线程安全的，这意味着如果多个线程同时访问和修改同一个HashMap，可能会导致数据不一致或其他问题。在多线程环境中，应该使用ConcurrentHashMap或采用适当的同步措施来确保线程安全

### 2.线程安全的Map有哪些，都是如何保证线程安全的

1.ConcurrentHashMap：ConcurrentHashMap是Java提供的线程安全的哈希表实现。它将数据分割为多个段（Segment），每个段都类似于一个小的HashTable，不同的线程可以同时访问不同的段，从而提供了更高的并发度。使用了锁分段技术，每个段都有一个锁，不同线程可以在不同的段上进行操作，从而减少了竞争。在Java 8及之后的版本中，ConcurrentHashMap引入了更高效的CAS操作和优化，进一步提升了性能。

2.Hashtable：Hashtable是一个早期的线程安全的哈希表实现，但相对较老且性能较差。它使用synchronized关键字来保证线程安全，但这也导致了较大的竞争和较低的并发性能。

### 3.HashSet和ArrayList的区别

1. **ArrayList**：
   - ArrayList是一个动态数组，它实现了List接口。它的内部是通过数组来实现的，可以根据需要动态调整数组的大小。
   - ArrayList允许元素的重复，可以存储相同的元素多次，并且有序，即元素的顺序与插入的顺序一致。
   - 通过索引访问元素的时间复杂度是O(1)，因为底层是数组，可以通过索引直接访问。
   - 插入和删除元素的时间复杂度通常是O(n)，因为在数组中间插入或删除元素需要移动其他元素来填充空缺。
2. **HashSet**：
   - HashSet是基于哈希表的数据结构，它实现了Set接口。HashSet中的元素是无序的，不允许有重复元素。
   - HashSet利用哈希函数对元素进行哈希计算，将元素映射到哈希表的不同位置，因此元素的存储顺序并不是插入的顺序。
   - 插入、删除和查找元素的时间复杂度通常是O(1)，因为哈希表通过哈希函数可以快速定位元素。
   - HashSet会自动去重，如果尝试添加重复元素，它不会导致集合中存在多个相同的元素。

使用场景建议：

- 如果需要存储大量元素并经常进行索引访问，那么选择ArrayList可能更合适，因为它支持快速的随机访问。
- 如果需要存储一组唯一的元素，并且对元素的顺序不关心，同时需要快速的插入、删除和查找操作，那么选择HashSet可能更适合。