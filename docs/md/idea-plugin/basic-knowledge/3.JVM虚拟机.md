### 1.JVM内存模型？

1. **程序计数器（Program Counter Register）**： 程序计数器用于存储当前线程正在执行的字节码指令的地址。每个线程都有自己的程序计数器，线程切换时会恢复到正确的执行位置，保证线程独立运行。
2. **Java虚拟机栈（JVM Stack）**： Java虚拟机栈也称为虚拟机栈或者Java栈，用于存储线程的方法调用和局部变量。每个方法在执行的时候会创建一个栈帧，栈帧用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。方法的调用和返回都是通过栈帧进行管理。
3. **本地方法栈（Native Method Stack）**： 本地方法栈与Java虚拟机栈类似，但是用于存储本地方法（Native Method）的调用和相关数据。本地方法是使用非Java语言（如C或C++）编写的，通过JNI（Java Native Interface）调用。在执行本地方法时，会使用本地方法栈。
4. **Java堆（Java Heap）**： Java堆是JVM中最大的一块内存区域，用于存储对象实例。所有通过new关键字创建的对象都会分配在堆上。Java堆是垃圾收集器主要进行回收的区域，当对象不再被引用时，垃圾收集器会回收该对象的内存，使得堆空间得以重复利用。
5. **方法区（Method Area）**： 方法区用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在HotSpot虚拟机中，方法区被称为“永久代（Permanent Generation）”，但在JDK8及以后版本中被移除，被元空间（Meta Space）所替代。
6. **运行时常量池（Runtime Constant Pool）**： 运行时常量池是方法区的一部分，用于存储编译期生成的字面量和符号引用。它包含类和接口的常量池表和字符串常量池。
7. **直接内存（Direct Memory）**： 直接内存并不是JVM运行时数据区的一部分，但是它是JVM内存模型中重要的一部分。直接内存通过NIO（New I/O）的ByteBuffer使用，不受Java堆大小的限制，直接与本地内存交互。它的内存分配和回收由Java虚拟机控制，可以通过`-XX:MaxDirectMemorySize`参数进行调整。

### 2.垃圾回收机制

Java的垃圾回收（Garbage Collection，简称GC）是一种自动内存管理机制，它负责自动识别和释放不再使用的内存对象，从而减少手动内存管理的复杂性和错误。Java的垃圾回收机制允许开发者专注于业务逻辑而无需过多关注内存分配与释放问题。

判断一个对象是否可被回收：

1.计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 

2.可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 

GC Roots 一般包含以下内容：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

Java中的垃圾回收算法包括以下几种：

1. 标记-清除（Mark-and-Sweep）：这是最基本的垃圾回收算法。它分为两个阶段：标记阶段，标记出所有活动对象；清除阶段，清除所有未被标记的对象。
2. 复制（Copying）：将堆分为两个部分，每次只使用其中一个。在当前活动部分中进行分配和垃圾回收，将存活的对象复制到另一部分，然后清除当前部分所有对象。
3. 标记-压缩（Mark-and-Compact）：类似于标记-清除算法，但会在标记阶段完成后，将所有存活的对象向一端移动，然后清理掉边界以外的内存。
4. 分代（Generational）：将堆分为新生代和老年代。新创建的对象首先分配到新生代，经过几次垃圾回收后，如果仍然存活，就会被移动到老年代。新生代使用较短的垃圾回收算法，而老年代使用较耗时但效率较高的算法。

### 3.JVM垃圾回收算法、以及具体工作原理

1.标记 - 清除

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png)

 

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

2.标记 - 整理

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png)

 

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

3.复制

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png)

 

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 4.JVM的内存分配策略

- 对象优先在 Eden 分配

  大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

- 大对象直接进入老年代

  大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

  经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

  -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

- 长期存活的对象进入老年代

  为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

  -XX:MaxTenuringThreshold 用来定义年龄的阈值。

- 动态对象年龄判定

  虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

- 空间分配担保

  在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

  如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

### 5.CMS垃圾收集器采用的什么回收算法、CMS垃圾收集器的STW阶段

CMS使用的是标记清除算法，CMS回收的区域是老年代。

CMS（Concurrent Mark-Sweep）垃圾收集器虽然在标记和清除阶段采用了并发的方式来减少停顿时间，但仍然需要在某些阶段执行停顿（Stop-The-World，STW）操作，以便完成一些关键的任务。STW 阶段是指应用程序的执行被暂停，以便进行垃圾收集器的工作。

在 CMS 垃圾收集器的工作过程中，主要有两个阶段需要进行 STW 暂停：

- 初始标记阶段（Initial Mark）： 在这个阶段，CMS 收集器会暂停应用程序的执行，然后标记与根对象直接关联的存活对象。这个阶段是必须的，因为它建立了垃圾收集的起始标记点，后续的并发标记和并发清除将围绕这个标记点进行。初始标记阶段通常是一个较短暂的停顿，因为它只涉及到与根对象的直接关联。
- 重新标记阶段（Remark）： 在并发标记阶段结束后，由于应用程序的并发运行，一些对象可能会发生变化，需要进行重新标记。在重新标记阶段，CMS 垃圾收集器会再次暂停应用程序，然后标记并跟踪在并发标记阶段之后发生变化的对象。这个阶段的停顿时间通常比初始标记阶段稍长，但仍然相对较短。

除了这两个主要的 STW 阶段，CMS 垃圾收集器还会在某些情况下执行短暂的 STW 暂停，例如在内存空间耗尽或者并发标记失败时。尽管 CMS 在标记和清除阶段使用了并发技术来减少停顿时间，但由于存在 STW 阶段，它仍然可能引起一些短暂的停顿。为了解决一些 CMS 的限制，并进一步减少停顿时间，Java 9 引入了 G1（Garbage-First）垃圾收集器，它采用了不同的分代和回收策略，以及更先进的算法，旨在提供更可预测的停顿时间。

### 6.CMS和G1垃圾收集器

CMS存在的问题：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

CMS（Concurrent Mark-Sweep）垃圾收集器：

**特点**：CMS是一种早期引入Java虚拟机的垃圾收集器，其主要目标是减少垃圾回收过程中的停顿时间，从而提高应用程序的响应性。它采用并发的方式，在某些阶段与应用程序线程一起运行，以减少主要的停顿时间。
**工作过程**：CMS的工作流程包括以下几个阶段：初始标记（Initial Mark）、并发标记（Concurrent Mark）、重新标记（Remark）、并发清除（Concurrent Sweep）和并发重置（Concurrent Reset）。
**适用场景**：CMS适用于注重减少停顿时间的应用程序，但可能会牺牲一些吞吐量。它适合运行在较小堆内存上的应用程序。
G1（Garbage-First）垃圾收集器：

**特点**：G1是一种相对较新的垃圾收集器，旨在提供更可控、更稳定的垃圾回收性能。它专注于整体吞吐量和可预测性能，同时通过划分堆内存为多个区域来实现分代收集的特性。
**工作过程**：G1的工作流程包括初始标记（Initial Mark）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation）、再处理（Cleanup）等阶段。G1通过这些阶段来高效地管理垃圾对象。
**适用场景**：G1适用于需要更稳定和可控的垃圾收集性能的应用程序，尤其在大内存场景下表现良好。
总的来说，选择使用CMS还是G1垃圾收集器取决于应用程序的需求和特点。如果注重降低停顿时间并可以容忍一些吞吐量的牺牲，可以考虑使用CMS。如果需要更稳定、可预测的性能，并且在大内存环境下工作，G1可能是更好的选择。

### 7.JVM调优策略

JVM（Java Virtual Machine）的调优是优化应用程序性能和内存管理的关键一步。以下是一些常见的 JVM 调优策略：

1. **内存设置**：
   - 堆内存大小：通过 `-Xmx` 和 `-Xms` 参数设置堆的最大和初始大小。确保分配足够的堆内存以容纳应用程序的对象，同时避免过多的堆内存导致频繁的垃圾回收。
   - 永久代/元空间大小：在 Java 8 及之前，使用 `-XX:MaxPermSize` 控制永久代的大小；在 Java 8+，使用 `-XX:MaxMetaspaceSize` 控制元空间大小。
2. **垃圾回收调优**：
   - 选择合适的垃圾回收器：根据应用程序性能需求选择合适的垃圾回收器（如串行、并行、CMS、G1 等）。
   - 调整垃圾回收参数：根据应用程序特点和硬件环境，调整相关的垃圾回收参数以达到最佳性能。例如，可以使用 `-XX:NewRatio` 来调整新生代和老年代的比例。
3. **对象管理**：
   - 避免过度创建对象：避免频繁的对象创建，尽量重用对象，减少垃圾回收的负担。
   - 使用对象池：对于一些频繁创建和销毁的对象，可以使用对象池来复用对象，减少垃圾回收的压力。
4. **线程管理**：
   - 控制线程数量：适当控制线程数量，避免过多的线程竞争和上下文切换带来的开销。
5. **性能分析**：
   - 使用性能分析工具：使用工具如 VisualVM、YourKit 等，监视应用程序的性能，找出瓶颈并进行调优。
   - 分析堆转储文件：通过分析堆转储文件，了解内存使用情况，找出内存泄漏和不必要的对象。

### 8.类加载器

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
- 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 9.类加载过程

包含了加载、验证、准备、解析和初始化这 5 个阶段。

1.加载

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

2.验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

3.准备

类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

```
public static final int value = 123;
```

4.解析

将常量池的符号引用替换为直接引用的过程。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

5.初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit\>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

### 10.双亲委派机制

 除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 

1.工作过程
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

2.好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

3.实现

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。