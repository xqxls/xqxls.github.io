### 1.笛卡尔积

在关系型数据库中，笛卡尔积是指两个表的所有可能组合的行的集合。当你在没有任何连接条件的情况下对两个表进行联接时，会生成笛卡尔积。这意味着第一个表的每一行都会与第二个表的每一行进行组合，从而生成新的行。

假设有两个表 A 和 B：

表 A：

| A_ID | A_Name |
| ---- | ------ |
| 1    | Alice  |
| 2    | Bob    |

表 B：

| B_ID | B_Value |
| ---- | ------- |
| 100  | X       |
| 200  | Y       |

如果你执行了没有连接条件的笛卡尔积查询（即没有使用任何 `JOIN` 条件）：

```sql
SELECT * FROM A, B;
```

结果将是：

| A_ID | A_Name | B_ID | B_Value |
| ---- | ------ | ---- | ------- |
| 1    | Alice  | 100  | X       |
| 1    | Alice  | 200  | Y       |
| 2    | Bob    | 100  | X       |
| 2    | Bob    | 200  | Y       |

可以看到，每一行都与另一个表中的每一行组合，从而生成了所有可能的组合。这种情况下的笛卡尔积可能会导致结果集非常大，特别是当表的行数很多时，所以通常应该避免无意义的笛卡尔积。要执行有意义的联接，应该使用适当的连接条件，例如使用 `INNER JOIN`、`LEFT JOIN`、`RIGHT JOIN` 等。

### 2.左连接情况下A、B表，返回多少数据

在左连接情况下，如果表 B 中有重复的元素，会导致在连接时出现多个匹配的情况。每个匹配都会生成一个新的行，因此结果中会包含多个相同的左侧表 A 的行，对应于表 B 中的重复元素。让我们看一个示例：

假设有两个表 A 和 B，以及以下数据：

表 A：

| A_ID | A_Name |
| ---- | ------ |
| 1    | Alice  |
| 2    | Bob    |

表 B：

| B_ID | B_Value |
| ---- | ------- |
| 1    | X       |
| 1    | Y       |

如果执行左连接查询：

```sql
SELECT * FROM A LEFT JOIN B ON A.A_ID = B.B_ID;
```

结果将是：

| A_ID | A_Name | B_ID | B_Value |
| ---- | ------ | ---- | ------- |
| 1    | Alice  | 1    | X       |
| 1    | Alice  | 1    | Y       |
| 2    | Bob    | NULL | NULL    |

在这个例子中，由于表 B 中的 B_ID 为 1 的行重复出现两次，它与表 A 中的 A_ID 为 1 的行都进行了匹配，从而产生了两行连接结果。因此，左连接返回了三行数据

### 3.select、where、group by、having、order by执行顺序

在 SQL 查询中，以下是 `SELECT`、`WHERE`、`GROUP BY`、`HAVING` 以及 `ORDER BY` 子句的执行顺序：

1. `SELECT`: 这是查询的起点，用于选择要从数据库中检索的列。在这一步中，数据库引擎会识别出需要返回的列。
2. `FROM`: 在这一步，数据库引擎确定数据来自哪个表。它会从指定的表中检索数据，以供后续处理。
3. `WHERE`: 在 `WHERE` 子句中，你可以定义条件来筛选要返回的行。只有满足 `WHERE` 条件的行才会被包含在结果中。
4. `GROUP BY`: 如果在查询中包含了聚合函数（如 `SUM`、`COUNT`、`AVG` 等），那么 `GROUP BY` 用于将数据分组，以便在每个组上执行聚合操作。数据将按照 `GROUP BY` 中指定的列进行分组。
5. `HAVING`: `HAVING` 子句用于在进行分组后，筛选掉不符合特定聚合条件的组。只有满足 `HAVING` 条件的组才会出现在结果中。
6. `ORDER BY`: 最后，`ORDER BY` 子句用于对结果进行排序。你可以指定一个或多个列来排序，以及升序或降序排列。

需要注意的是，虽然这是一般情况下的执行顺序，但数据库引擎在实际执行查询时可能会进行优化，以提高查询性能。在某些情况下，它可能会重新排列这些步骤，以获得更高效的查询执行计划。

### 3.select count(1)和select count(*)的区别

在大多数关系型数据库中，`SELECT COUNT(1)` 和 `SELECT COUNT(*)` 都可以用来统计表中的行数，但它们在一些方面存在微小的区别：

1. **语法：**

   `SELECT COUNT(1)`：在这种情况下，数据库将选择每一行中的第一个列（通常是主键列），然后对选定的值计数。实际上，它只是选择了一列的数据，但是由于每一行都被选择了一个值，所以实际上是在统计行数。

   `SELECT COUNT(*)`：在这种情况下，数据库会选择所有列的数据，但实际上并不会返回这些数据。它只是计算行数，因为每一行都被计数。

2. **性能：**

   `SELECT COUNT(1)`：由于只选择了一个固定的值（1），数据库系统不需要检索表中的实际数据，只需遍历行数进行计数。这可以在某些情况下稍微快一些。

   `SELECT COUNT(*)`：虽然也只计数行数，但是由于要选择所有列，数据库系统可能需要读取表中的部分数据（或者全部数据，具体取决于查询优化和数据库引擎的实现），这可能会在某些情况下略微慢一些。

3. **优化：**

   某些数据库管理系统可能会针对这两种形式的计数进行不同的优化，以提高查询性能。但总体来说，这两种形式的性能差异可能很小，具体结果可能因数据库引擎、表的结构、数据量和索引情况而异。

### 4.什么时候考虑分库、什么时候考虑分表，数据量多大考虑分库分表

考虑分库的情况：

- 数据量过大： 当单个数据库的数据量变得过大，超出了数据库管理系统的性能限制，分库是一个选择。分库将数据分散到多个数据库中，每个数据库处理自己的一部分数据，从而减轻单个数据库的负担。
- 数据隔离需求： 如果需要将不同类型、不同用途的数据进行隔离，例如将用户数据和订单数据存储在不同的数据库中，分库可以帮助实现更好的数据隔离。
- 地理位置： 当应用需要在不同地理位置部署多个数据中心或服务器时，可以考虑分库，每个地理位置一个数据库，以降低延迟。
- 扩展性要求： 当需要在多台服务器上进行水平扩展时，可以将不同的服务器配置为不同的数据库，实现更好的负载均衡和扩展性。

考虑分表的情况：

- 单表数据过大： 当单个表的数据量过大，导致查询性能下降，分表是一种解决方案。分表将表中的数据分散到多个表中，每个表处理自己的一部分数据。
- 热点数据： 如果某些数据行频繁访问，导致锁竞争和性能瓶颈，可以考虑将这部分数据分到单独的表中，减少锁冲突。
- 垂直分表： 当表中包含多种类型的数据，但每种类型的数据又具有不同的访问频率和特性时，可以考虑将不同类型的数据分到不同的表中，以优化查询性能。
- 历史数据和归档： 对于大量历史数据和归档数据，可以将其分到独立的表中，以减少对主要业务表的影响。

需要注意的是，分库和分表都会引入一些复杂性，包括跨库事务、数据关联、查询跨库等问题。在做决策时，需要综合考虑应用的需求、数据库管理成本以及维护难度。往往可以先通过优化单库单表性能来延缓分库分表的引入，只有在必要时才考虑这些扩展手段。

决定何时考虑分库分表是一个复杂的问题，因为它取决于多个因素，包括数据库引擎、硬件性能、应用程序负载和查询模式等。然而，一般来说，当数据量达到一定程度时，考虑分库分表是合理的：

分库的情况：

- 数十亿到千亿级别的数据： 当单个数据库无法容纳数十亿到千亿级别的数据时，考虑将数据分布到多个数据库中。
- 数据库性能达到极限： 当单个数据库的性能达到了极限，无法继续提供满足应用需求的性能时，可以考虑分库来分担负载。

分表的情况：

- 单表数据量超过千万、亿级别： 当单个表的数据量超过千万或亿级别，查询性能开始下降，或者维护成本变得不可控时，考虑分表。
- 频繁的数据更新和插入操作： 当数据更新和插入操作频繁，导致锁竞争和性能问题，分表可以减轻压力。
- 热点数据问题： 如果有热点数据导致性能瓶颈，可以将热点数据分到单独的表中，以减少锁竞争。

### 5.MySQL索引，为什么选择B+树，如果用B树，红黑树，缺点是什么

1.数据结构：B+树

2.为什么选择B+树

- B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
- B+树的数据全部存放在叶子节点，非叶子节点只存放索引，不放数据，所以B+树的高度会更低一点，可以减少磁盘寻道次数。

3.B树的缺点

- 非叶子节点存放数据
- B 树的节点分裂和合并需要频繁地调整树的结构，不支持高度动态的场景

4.红黑树的缺点

- 范围查询性能差
- 当节点数过多时，高度会急速增加，影响性能

### 6.数据库的索引

按照数据结构维度划分：

- BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。
- 哈希索引：类似键值对的形式，一次即可定位。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

按照底层存储方式角度划分：

- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。

### 7.使用索引的好处

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 8.如何优化SQL查询？优化索引？对于explain语句里面常见的字段含义是什么？索引失效场景？

1.优化sql查询

- 选择合适的索引
- 尽量使用limit
- 使用连表查询而不是子查询
- 查询的时候，返回需要的字段而不是全部字段

2.优化索引

- 需要使用多个列作为查询条件时，尽量使用多列索引
- 把选择性更强的列放在前面
- 使用覆盖索引
- 注意索引的失效场景

3.explain语句里常见字段含义

- select_type : 查询类型，有简单查询、联合查询、子查询等
- type： 表示访问类型，用于表示查询的访问方式，如ALL（全表扫描）、index（使用索引扫描）、range（范围查询）等。
- key : 使用的索引
- rows : 扫描的行数

4.explain语句里常见字段含义

- 函数操作
- 模糊查询以通配符开头
- 列类型不匹配
- 联合索引不是以最左列为查询条件
- 使用not in【数据分布不均匀、较大的值列表、NULL值】 （可以用not exists替代）

### 9.MySQL事务，ACID，隔离级别

1.Mysql事务：

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 

2.ACID：

1. **原子性（Atomicity）**

   事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. **一致性（Consistency）**

   数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3. **隔离性（Isolation）**

   一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. **持久性（Durability）**

   一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

3.隔离级别

- 未提交读（READ UNCOMMITTED）
  事务中的修改，即使没有提交，对其它事务也是可见的。
- 提交读（READ COMMITTED）
  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- 可重复读（REPEATABLE READ）
  保证在同一个事务中多次读取同一数据的结果是一样的。
- 可串行化（SERIALIZABLE）
  强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

### 10.各个隔离级别分别解决了什么问题

- 未提交读（READ UNCOMMITTED）
  事务中的修改，即使没有提交，对其它事务也是可见的。
- 提交读（READ COMMITTED）
  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决了脏读的问题。
- 可重复读（REPEATABLE READ）
  保证在同一个事务中多次读取同一数据的结果是一样的。解决了脏读和不可重复读的问题。
- 可串行化（SERIALIZABLE）
  强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。解决了脏读、不可重复读和幻读的问题。

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | ×    | ×          | ×    |
| 提交读   | ✓    | ×          | ×    |
| 可重复读 | ✓    | ✓          | ×    |
| 可串行化 | ✓    | ✓          | ✓    |

Mysql默认的隔离级别是可重复读。

Oracle默认的隔离级别是提交读。

### 11.聊聊MVCC

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

基本思想：

在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

### 12.数据库优化

1.选择合适的索引

2.合理的表设计（避免冗余字段和多对多关系、使用合适的数据类型避免浪费存储空间）

3.使用缓存

4.使用批量操作

5.使用数据库连接池

6.定期进行性能测试

### 13.分布式事务问题

1.本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。

- 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
- 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
- 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

2.lcn

3.seata