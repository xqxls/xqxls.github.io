# 题目描述
> 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
> 示例 1：
> 输入：nums = [3,4,3,3] 
> 输出：4 示例 2：
> 输入：nums = [9,1,7,9,7,9,7] 
> 输出：1   
> 限制：
> 1 <= nums.length <= 10000 
> 1 <= nums[i] < 2^31

## 方法一（位运算）
#### 1.解题思路
首先新建一个位数组，遍历nums数组中的每一个数的每一位，如果某一位是1，就加入到对应的位数组，由于其他数字都出现了三次，所以对应位的和一定是3或0。把所有数的位相加，再对3取余，剩下的位对应的就是只出现一次的数。
#### 2.代码实现

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] bit=new int[32];
        for(int num:nums){
        	//用于判断某一位是否是1
            int flag=1;
            for(int i=31;i>=0;i--){
                if((num&flag)!=0){
                    bit[i]+=1;              
                }   
                flag<<=1;           
            }
        }
        //通过位数组获取只出现一次的数
        int res=0;
        for(int i=0;i<32;i++){
            res<<=1;
            res|=bit[i]%3;
            
        }
        return res;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：需要遍历一次nums数组，每一次循环又需要遍历位数组logC次（C是数组中数字的范围），所以时间复杂度为O(nlogC)。
 - 空间复杂度：需要额外常数级别的位数组，所以空间复杂度为O(1)。

## 方法二（状态机）
#### 1.解题思路
 - 分析：在方法一中我们引入了位数组，对每一个数的每一位进行运算，那么可以把每个数看成一个整体进行位运算吗？我们可以通过状态机实现这个过程（需要具备一定数字电路设计基础，门电路，真值表，时序逻辑电路设计等）。
 - 方案：可以使用一个黑盒存储每一个数的所有位对3取余，记为x~i~（i=0，1……n），那么x~i~可以取0，1或2。所以我们用两个二进制位来表示这三种状态（00，01，10），两个二进制位分别记为a和b。
 - 状态转移：当x~i~为0时，状态不变；当x~i~为1时，按照(00)→(01)→(10)→(00) 的循环进行变化。
 - 真值表与状态转移表达式：

  真值表：
  | a~i~b~i~     | x~i~ | 新的a~i~b~i~
  |-------- | -----  | -----
  | 00      | 0      |  00
  | 00      | 1      | 0**1**
  | 01      | 0      | 0**1**
  | 01      | 1      | 10
  | 10      | 0      | 10
  | 10      | 1      | 00

  计算b~i~：
  1.状态转移表达式 ：

  b~i~=a~i~^′^b~i~^′^ x~i~+a~i~^′^b~i~ x~i~^′^  =a~i~^′^ （b~i~⊕x~i~）

  2.转换为等价的整数位运算是：

  b=(b^x~i~)&~a

  计算a~i~：
  由于b~i~已经跟新过了，所以我们计算a~i~时，使用新的b~i~，于是有如下真值表
  新的真值表：
  | a~i~b~i~     | x~i~ | 新的a~i~b~i~
  |-------- | -----  | -----
  | 00      | 0      | 00
  | 01      | 1      | 01
  | 01      | 0      | 01
  | 00      | 1      | **1**0
  | 10      | 0      | **1**0
  | 10      | 1      | 00	

  1.状态转移表达式 ：

  a~i~=a~i~^′^b~i~^′^ x~i~+a~i~b~i~ ^′^x~i~^′^  =b~i~^′^ （a~i~⊕x~i~）

  2.转换为等价的整数位运算是：

  a=(a^x~i~)&~b
 - 总结：计算完所有的数之后，由于每一位的余数要么是0，要么是1，所以状态只能是(ab=00)或(ab=01)，从而最后的状态只与b相关，返回b即是只出现一次的数。
#### 2.代码实现

```java
class Solution {
    public int singleNumber(int[] nums) {
    	//ones表示b，twos表示a
        int ones=0,twos=0;
        for(int num:nums){
            ones=(ones^num)&~twos;
            twos=(twos^num)&~ones;
        }
        return ones;
    }
}

```
#### 3.复杂度分析
> 与方法一相比，时间和空间复杂度都有较大幅度的提升
 - 时间复杂度：需要遍历一次nums数组，所以时间复杂度为O(n)。
 - 空间复杂度：需要额外常数级别的内存空间，所以空间复杂度为O(1)。
