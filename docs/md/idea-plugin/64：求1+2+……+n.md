# 题目描述
> 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
> 示例 1：
> 输入: n = 3 
> 输出: 6 
> 示例 2：
> 输入: n = 9 
> 输出: 45  
> 限制：
> 1 <= n <= 10000
## 方法一（递归+开关特性）
#### 1.解题思路
boolean flag=A&&B，如果A条件不成立，则flag直接为false，B不会执行。所以可以利用这个特点设置递归的终止条件，当n为1时，不再满足n>1，后面的累加也不会再继续。
#### 2.代码实现

```java
class Solution {
    public int sumNums(int n) {
        int sum=n;
        boolean flag=n>1&&(sum+=sumNums(n-1))>0;
        return sum;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：需要累加n个数字，所以时间复杂度为O(n)。
 - 空间复杂度：递归栈的深度为n，所以空间复杂度为O(n)。

## 方法二（快速乘）
#### 1.解题思路
我们知道累加和为n\*(n+1)/2，所以只要计算出n\*(n+1)再右移一位就得到了所求的值。可以利用移位、累加的方式模拟乘法。

```bash
比如2（二进制为010）与3（二进制为011）的乘积计算过程：

		010
	   *011
	 =  010
	   010
	 = 0110
```
举例说明：如果A为011，B为010，计算A\*B时，若A的当前位为1，则将B左移对应的位，然后加到结果集，直到A为0.

因为n最大为10000，不超过2的14次幂，所以最多移位14次即可得出结果。
#### 2.代码实现
利用循环（不合题意）：
```java
class Solution {
    public int sumNums(int n) {
        int A=n,B=n+1,res=0;
        boolean f;
        
        for(;A>0;){
            f= (A&1)>0 && (res+=B)>0;
            A>>=1;
            B<<=1;
        }

        return res>>1;
    }
}
```

穷举14次：

```java
class Solution {
    public int sumNums(int n) {
        int A=n,B=n+1,res=0;
        boolean f;
        
        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        f=(A&1)>0 && (res+=B)>0;
        A>>=1;
        B<<=1;

        return res>>1;

    }
}
```

#### 3.复杂度分析
 - 时间复杂度：计算次数为n的位数，所以时间复杂度为O(logn)。
 - 空间复杂度：需要额外常熟级别的空间，所以空间复杂度为O(1)。

## 方法三（乘方+位运算）
#### 1.解题思路
直接通过乘方+移位，计算出n\*(n+1)/2的值。
#### 2.代码实现
```java
class Solution {
    public int sumNums(int n) {
        return ((int)Math.pow(n,2)+n)>>1;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：只有乘方和位运算，所以时间复杂度为O(1)。
 - 空间复杂度：不需要额外的内存空间，所以空间复杂度为O(1)。
