# 题目描述
> 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
> 示例 1:
> 输入: 1 
> 输出: 
> [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 
> 示例 2:
> 输入: 2 
> 输出:
> [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
> 限制：
> 1 <= n <= 11

## 方法一（动态规划）
#### 1.解题思路

 - 状态定义：dp[i][j]表示有i个骰子时，骰子点数和为j的可能数
 - 状态初始化：当只有一个骰子时，和为1到6的可能性都是1种
 - 状态转移方程：从第i-1个骰子到第i个骰子，只能掷出1到6共6个点数，所以我们把六种可能的dp累加，可组成当前dp，即dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]+dp[i-1][j-4]+dp[i-1][j-5]+dp[i-1][j-6]
 - 计算概率：n个骰子最小的点数和为n（都是1），最大的点数和为6n（都是6），所以总共有5n+1种不同的点数和，而总的可能数为6^n^ ，根据之前计算出的每种点数和的可能数除以这个总可能数，即可得到概率。
#### 2.代码实现

```java
class Solution {
    public double[] dicesProbability(int n) {
        int[][] dp=new int[n+1][6*n+1];
        double[] res=new double[5*n+1];
        double All=Math.pow(6,n);
        for(int j=1;j<=6;j++){
            dp[1][j]=1;
        }
        for(int i=2;i<=n;i++){
            for(int j=6*n;j>=1;j--){
                for(int k=1;k<=6;k++){
                    if(j>=k){
                        dp[i][j]+=dp[i-1][j-k];
                    }                 
                }              
            }
        }
        for(int i=0;i<=5*n;i++){
            res[i]=dp[n][i+n]/All;
        }
        return res;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：最多两层循环，所以时间复杂度为O(n^2^)。
 - 空间复杂度：需要额外O(n^2^)空间存储dp状态，所以空间复杂度为O(n^2^)。

## 方法二（空间压缩）
#### 1.解题思路
由于每次dp只与之前少一个骰子的状态有关，所以可能用一个变量记录少一个骰子时的状态，当达到n个骰子时，提前计算概率。
#### 2.代码实现

```java
class Solution {
    public double[] dicesProbability(int n) {
        int[] dp=new int[6*n+1];
        double[] res=new double[5*n+1];
        double All=Math.pow(6,n);
        for(int i=1;i<=6;i++){
            dp[i]=1;
            res[i-1]=1/All;
        }
        for(int i=2;i<=n;i++){
            for(int j=6*n;j>=1;j--){
                int temp=0;
                for(int k=1;k<=6;k++){
                    temp+=j>=k?dp[j-k]:0;
                }
                dp[j]=temp;
                if(i==n&&j>=n){
                    res[j-i]=dp[j]/All;
                }
            }
        }
        return res;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：最多两层循环，所以时间复杂度为O(n^2^)。
 - 空间复杂度：需要额外O(n)空间存储dp状态，所以空间复杂度为O(n)。
