## 题目描述
> 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即x^n^）。不得使用库函数，同时不需要考虑大数问题。
> 示例 1：
> 输入：x = 2.00000, n = 10 
> 输出：1024.00000 
> 示例 2：
> 输入：x = 2.10000, n = 3 
> 输出：9.26100 
> 示例 3：
> 输入：x = 2.00000, n = -2 
> 输出：0.25000 
> 解释：2^-2^ = 1/2^2^ = 1/4 = 0.25  
> 提示：
> -100.0 < x < 100.0
> -2^31^ <= n <= 2^31^-1
> -10^4^ <= x^n^ <= 10^4^

## 方法一（快幂法）
#### 1.解题思路

 - 计算x的n次幂，可以考虑把指数n不断除2，底数x相应变为自己的平方，乘到结果里，如果在这个过程中，指数n为奇数，则在结果里再乘以一个底数x，同时n自减1，当指数n为0时，整个过程就结束了，最终的结果，其值就是x的n次幂。
 - 如果n小于0，则对应地，设一个变量b为n，然后通过b进行操作，同时x变为1/x，b变为-b。
 - 因为java中32为整型范围为（-2^31^ ，2^31^-1），当n为-2^31^ 时，取反操作会越界，所以，可以设b的类型为long。

#### 2.代码实现

```java
class Solution {
    public double myPow(double x, int n) {
        if(n==0) return 1;
        long b=n;
        if(n<0){
            x=1.0/x;
            b=-b;
        }
        double res=1.0;
        while(b!=0){
            if(b%2==1){
                res*=x;
                b-=1;
            }
            x*=x;
            b/=2;
        }
        return res;
    }
}
```
#### 3.复杂度分析

 - 时间复杂度：数字n在循环过程中不断二分，直到变为0，所以时间杂度是O(log~2~n)
 - 空间复杂度：不需要额外的空间开销，所以空间复杂度为O(1)

## 方法二（递归）
#### 1.解题思路
  1. 递归终止条件：当n为0，1或-1时，可以直接返回对应的值。
  2. 从上一层递归获取什么：由于每一层都需要对指数n除2，所以需要获取上一层除2之后的那一半，如果不能被2整除，还需要获取上一层除2之后的余数。
  3. 每一层返回什么：返回上一层所得一半的平方再乘以余数，比如2^7^=2^3^*2^3^*2^1^

#### 2.代码实现

```java
class Solution {
    public double myPow(double x, int n) {
        if(n==0) return 1;
        if(n==1) return x;
        if(n==-1) return 1.0/x;
        double half=myPow(x,n/2);
        double mod=myPow(x,n%2);
        return half*half*mod;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：数字n在循环过程中不断二分，直到变为0，所以时间杂度是O(log~2~n)
 - 空间复杂度：递归栈的深度为2分的次数，所以空间复杂度为O(log~2~n)
