# 题目描述
> 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
> 示例:
> 输入: a = 1, b = 1 
> 输出: 2  
> 提示：
> a, b 均可能是负数或 0 结果不会溢出 32 位整数

## 方法一（位运算+递归）
#### 1.解题思路
首先需要了解数电中的二进制相加原理，这个题的计算，相当于一个简单的半加器。比如a，b都用二进制表示，用一位二进制数表示a，b，sum为和，carry为进位。则真值表如下：
|a     | b |sum     | carry
|-------- | ----- |-------- | -----
|0  | 0 |0  | 0
|0  | 1 |1  | 0
|1  | 0 |1  | 0
|1  | 1 |0  | 1

根据真值表可以得到：
```bash
sum=a^b;
carry=a&b;
```

所以我们把每次相加的结果用sum和carry保存起来，下次再用sum和carry代替a，b重复相加过程，直到b为0。
#### 2代码实现
```java
class Solution {
    public int add(int a, int b) {
        if(b==0){
            return a^b;
        }
        return add(a^b,(a&b)<<1);
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：递归的次数为进位的次数，最多有32位，所以时间复杂度为O(1)。
 - 空间复杂度：递归栈的深度为进位的次数，所以空间复杂度为O(1)。
## 方法二（位运算+迭代）
#### 1.解题思路
思路与递归一致，不过用变量来存储中间结果，最后的sum即是a。迭代的方式占用的空间相比递归有很大的节省。
#### 2代码实现
基础版：
```java
class Solution {
    public int add(int a, int b) {
        int sum=0;
        int carry=0;
        while(b!=0){
            sum=a^b;
            carry=(a&b)<<1;
            a=sum;
            b=carry;
        }

        return a;
    }
}
```
简化版：

```java
class Solution {
    public int add(int a, int b) {
        while(b!=0){
            int sum=a^b;
            b=(a&b)<<1;
            a=sum;
        }
        return a;
    }
}
```
#### 3.复杂度分析
 - 时间复杂度：循环的次数为累加过程中，进位的次数，最多有32位，所以时间复杂度为O(1)。
 - 空间复杂度：需要常熟级别的空间，所以空间复杂度为O(1)。
