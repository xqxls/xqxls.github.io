## 题目描述 
>  给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
>
>  测试用例的答案是一个 **32-位** 整数。
>
>  **子数组** 是数组的连续子序列。
>
>   
>
>  **示例 1:**
>
>  ```
>  输入: nums = [2,3,-2,4]
>  输出: 6
>  解释: 子数组 [2,3] 有最大乘积 6。
>  ```
>
>  **示例 2:**
>
>  ```
>  输入: nums = [-2,0,-1]
>  输出: 0
>  解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
>  ```


## 方法一（动态规划）
#### 1.解题思路
这个问题与求最大子数组和很相似。我们同样可以利用求子数组和的思路，每次求当前的最大子数组乘积，最后取最大的那个。只是会遇到负数的情况，那么可以同时求最小值和最大值，当遇到负数时，只需交换最小值和最大值即可。

#### 2.代码实现
```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        int min =1 ,max =1;
        int res = Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            if(nums[i]<0){
                int temp = min;
                min = max;
                max = temp;
            }
            min = Math.min(nums[i],min*nums[i]);
            max=  Math.max(nums[i],max*nums[i]);
            res = Math.max(res,max);
        }
        return res;
    }
}
```
#### 3.复杂度分析

- 时间复杂度：只需遍历一次数组，所以时间复杂度为O(n)。

- 空间复杂度：需要额外常数级别的空间，所以空间复杂度为O(1) 。

