## 题目描述
> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
>  
>
> **示例 1：**
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> **示例 2：**
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```


## 方法一（回溯）
#### 1.解题思路
首先对数组进行排序，然后固定左边的位置，对于右边的两个下标，利用双指针进行定位。当三数之和恰好为0时，将对应三元组加到结果集。需要注意的是重复三元组情况的处理，分两种情况，其一是：直接在左端点处理，如果前一个相同元素已经查找过了，则当前位置直接跳过；其二是：如果遇到满足条件的三元组，先不要加到结果集，而是将左指针移到最后一个相同的位置，同时右指针移到最后一个相同的位置，然后才加到结果集。

#### 2.代码实现
```java
class Solution {

    private String[] map = new String[]{"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> res = new ArrayList<>();
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0) return res;
        dfs(digits,0,new StringBuilder());
        return res;
    }

    private void dfs(String digits,int index,StringBuilder sb){
        if(index == digits.length()){
            res.add(sb.toString());
            return;
        }
        String s = map[digits.charAt(index)-'2'];
        for(char c:s.toCharArray()){
            sb.append(c);
            dfs(digits,index+1,sb);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```
#### 3.复杂度分析

 - 时间复杂度：两层循环，总共需要遍历n\*n\*(n-1)/2次，排序的时间复杂度为o(n*logn)所以时间复杂度为O(n\*n\*n) 。

 - 空间复杂度：不需要额外的空间，所以空间复杂度为O(1) 。
