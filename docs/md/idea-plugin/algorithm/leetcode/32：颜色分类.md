## 题目描述 
>  给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
>  我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。
>
>
>  必须在不使用库内置的 sort 函数的情况下解决这个问题。
>
>   
>
>  **示例 1：**
>
>  ```
>  输入：nums = [2,0,2,1,1,0]
>  输出：[0,0,1,1,2,2]
>  ```
>
>  **示例 2：**
>
>  ```
>  输入：nums = [2,0,1]
>  输出：[0,1,2]
>  ```


## 方法一（双指针）
#### 1.解题思路
定义两个指针l、r，分别指向开始位置和结束位置。直接遍历数组，如果当前位置为0，则交换当前位置和左指针指向的位置，同时游标右移，左指针也右移；如果当前位置为2，则交换当前位置和右指针指向的位置，同时右指针左移；如果当前位置为1，则无需交换，直接右移游标。

#### 2.代码实现
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i=0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int j=0;j<n;j++){
            dp[0][j] = 1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```
#### 3.复杂度分析

- 时间复杂度：只需遍历一次，所以时间复杂度为 O(n)。

- 空间复杂度：需要额外常数级别的空间，所以空间复杂度为O(1) 。

