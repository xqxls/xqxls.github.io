## 题目描述 
>  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
>  百度百科 中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
>   
>
>  **示例 1：**
>
>  ```
>  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
>  输出：3
>  解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
>  ```
>
>  **示例 2：**
>
>  ```
>  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
>  输出：5
>  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
>  ```
>
>  **示例 3：**
>
>  ```
>  输入：root = [1,2], p = 1, q = 2
>  输出：1
>  ```


## 方法一（递归）
#### 1.解题思路
递归的含义为能否在二叉树中找到值等于p或者等于q的节点。如果左子树、右子树中都能找到，说明祖先在根节点，直接返回root；如果只在左子树找到，则返回左子树；如果只在右子树找到，则返回右子树；如果都找不到，则返回null。

#### 2.代码实现
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null||root.val==p.val||root.val==q.val){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null){
            return root;
        }
        else if(left!=null){
            return left;
        }
        else if(right!=null){
            return right;
        }
        else{
            return null;
        }
    }
}
```
#### 3.复杂度分析

- 时间复杂度：只需遍历一次二叉树，所以时间复杂度为O(n)。
- 空间复杂度：最坏情况下，需要额外大小为n的递归栈，所以空间复杂度为O(n) 。

