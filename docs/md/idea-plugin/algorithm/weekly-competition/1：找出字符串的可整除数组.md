## 题目描述
> 给你一个下标从 **0** 开始的字符串 `word` ，长度为 `n` ，由从 `0` 到 `9` 的数字组成。另给你一个正整数 `m` 。
>
> `word` 的 **可整除数组** `div`  是一个长度为 `n` 的整数数组，并满足：
>
> - 如果 `word[0,...,i]` 所表示的 **数值** 能被 `m` 整除，`div[i] = 1`
> - 否则，`div[i] = 0`
>
> 返回 `word` 的可整除数组。
>
> **示例 1：**
>
> ```
> 输入：word = "998244353", m = 3
> 输出：[1,1,0,0,0,1,1,0,0]
> 解释：仅有 4 个前缀可以被 3 整除："9"、"99"、"998244" 和 "9982443" 。
> ```
>
> **示例 2：**
>
> ```
> 输入：word = "1010", m = 10
> 输出：[0,1,0,1]
> 解释：仅有 2 个前缀可以被 10 整除："10" 和 "1010" 。
> ```


## 方法一（转为整数并取余）
#### 1.解题思路
遍历整个字符串，依次获取从0索引到当前索引下字符串对应的整数值，并且每次计算之后，对m进行取余，防止超过整数最大值溢出（取余对最终判断是否能被m整除无影响）。

如果取余之后，余数为0，说明能整除，赋值为1；否则，赋值为0。

#### 2.代码实现
```java
class Solution {
    public int[] divisibilityArray(String word, int m) {
        int n = word.length();
        long cur = 0L;
        int[] div = new int[n];
        for(int i=0;i<n;i++){
            cur = cur*10+word.charAt(i)-'0';
            cur%=m;
            if(cur == 0){
                div[i] = 1;
            }
        }
        return div;
    }
}      
```
#### 3.复杂度分析

 - 时间复杂度：只需遍历一次，时间复杂度为O(n)。 
 - 空间复杂度：O(1)。
