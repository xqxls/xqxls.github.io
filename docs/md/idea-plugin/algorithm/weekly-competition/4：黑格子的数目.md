## 题目描述
> 给你两个整数 `m` 和 `n` ，表示一个下标从 **0** 开始的 `m x n` 的网格图。
>
> 给你一个下标从 **0** 开始的二维整数矩阵 `coordinates` ，其中 `coordinates[i] = [x, y]` 表示坐标为 `[x, y]` 的格子是 **黑色的** ，所有没出现在 `coordinates` 中的格子都是 **白色的**。
>
> 一个块定义为网格图中 `2 x 2` 的一个子矩阵。更正式的，对于左上角格子为 `[x, y]` 的块，其中 `0 <= x < m - 1` 且 `0 <= y < n - 1` ，包含坐标为 `[x, y]` ，`[x + 1, y]` ，`[x, y + 1]` 和 `[x + 1, y + 1]` 的格子。
>
> 请你返回一个下标从 **0** 开始长度为 `5` 的整数数组 `arr` ，`arr[i]` 表示恰好包含 `i` 个 **黑色** 格子的块的数目。
>
>  
>
> **示例 1：**
>
> ```
> 输入：m = 3, n = 3, coordinates = [[0,0]]
> 输出：[3,1,0,0,0]
> 解释：网格图如下：
> 
> 只有 1 个块有一个黑色格子，这个块是左上角为 [0,0] 的块。
> 其他 3 个左上角分别为 [0,1] ，[1,0] 和 [1,1] 的块都有 0 个黑格子。
> 所以我们返回 [3,1,0,0,0] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]
> 输出：[0,2,2,0,0]
> 解释：网格图如下：
> 
> 有 2 个块有 2 个黑色格子（左上角格子分别为 [0,0] 和 [0,1]）。
> 左上角为 [1,0] 和 [1,1] 的两个块，都有 1 个黑格子。
> 所以我们返回 [0,2,2,0,0] 。
> ```


## 方法一（哈希表）
#### 1.解题思路
考虑一个黑格子能使哪些块的黑格子数加1，很明显，如果黑格子的下标为(x,y)。则左上角为(x-1,y-1),(x-1,y),(x,y-1),(x,y)的块的黑格子数会加1。所以只需遍历所有黑格子，然后将对应块的黑格子数累加即可。最后还差不包含黑格子的块没有计算，只需用总数目减去其他数目累加和。

#### 2.代码实现
```java
class Solution {
    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {
        long[] res = new long[5];
        long k = (m-1L) * (n-1L);
        int len = coordinates.length;

        Map<Long,Integer> map = new HashMap<>();
        long mul = (long)n;
        for(int[] c:coordinates){
            Long p1 = c[0]*mul+c[1];
            Long p2 = (c[0]-1)*mul+c[1];
            Long p3 = c[0]*mul+c[1]-1;
            Long p4 = (c[0]-1)*mul+(c[1]-1);
            if(c[0]>=0&&c[0]<m-1&&c[1]>=0&&c[1]<n-1){
                map.put(p1,map.getOrDefault(p1,0)+1);
            }
            if(c[0]-1>=0&&c[0]-1<m-1&&c[1]>=0&&c[1]<n-1){
                map.put(p2,map.getOrDefault(p2,0)+1);
            }
            if(c[0]>=0&&c[0]<m-1&&c[1]-1>=0&&c[1]-1<n-1){
                map.put(p3,map.getOrDefault(p3,0)+1);
            }
            if(c[0]-1>=0&&c[0]-1<m-1&&c[1]-1>=0&&c[1]-1<n-1){
                map.put(p4,map.getOrDefault(p4,0)+1);
            }
        }
        for(Long key:map.keySet()){
            Integer value = map.get(key);
            res[value] += 1;
        }
        res[0] = k- map.size();
        return res;
    }
    
}
```
#### 3.复杂度分析

 - 时间复杂度：只需遍历所有黑格子，假设黑格子数目为k，则时间复杂度为O(k)。
 - 空间复杂度：需要额外大小为k的哈希表，所以空间复杂度为O(k)。
