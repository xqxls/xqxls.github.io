## 题目描述
> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个正整数 `k` 。
>
> 你可以对数组执行下述操作 **任意次** ：
>
> - 从数组中选出长度为 `k` 的 **任一** 子数组，并将子数组中每个元素都 **减去** `1` 。
>
> 如果你可以使数组中的所有元素都等于 `0` ，返回  `true` ；否则，返回 `false` 。
>
> **子数组** 是数组中的一个非空连续元素序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,2,3,1,1,0], k = 3
> 输出：true
> 解释：可以执行下述操作：
> - 选出子数组 [2,2,3] ，执行操作后，数组变为 nums = [1,1,2,1,1,0] 。
> - 选出子数组 [2,1,1] ，执行操作后，数组变为 nums = [1,1,1,0,0,0] 。
> - 选出子数组 [1,1,1] ，执行操作后，数组变为 nums = [0,0,0,0,0,0] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,3,1,1], k = 2
> 输出：false
> 解释：无法使数组中的所有元素等于 0 。
> ```


## 方法一（差分数组）
#### 1.解题思路
首先初始化差分数组。然后遍历差分数组，将i+k处差分数组值增加i处差分数组值。增加之后，对应差分数组的值应全部为0。

#### 2.代码实现
```java
class Solution {
    public boolean checkArray(int[] nums, int k) {
        int n = nums.length;
        int[] diff = new int[n];
        diff[0] = nums[0];
        for(int i=1;i<n;i++){
            diff[i] = nums[i] - nums[i-1];
        }
        for (int i = 0; i < n; i++) {
            if(diff[i]<0){
                return false;
            }
            else if(diff[i]==0){
                continue;
            }
            else{
                if(i+k>n){
                    return false;
                }
                else if(i+k<n){
                    diff[i+k] += diff[i];
                }
            }
        }
        return true;
    }
}
```
#### 3.复杂度分析

 - 时间复杂度：只需一层循环，所以时间复杂度为O(n)。
- 空间复杂度：需要额外大小为n的差分数组，所以空间复杂度为O(n)。
